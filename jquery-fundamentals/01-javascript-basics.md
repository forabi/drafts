أساسيّات jQuery‏ (1): أساسيّات JavaScript
=====================================

بُنيت jQuery على لغة JavaScript، وهي لغةٌ غنيّة وقويّة في حدّ ذاتها. يُغطّي هذا القسم أساسيّات لغة JavaScript، وبعض الأخطاء الشّائعة الّتي يرتكبها المبتدئون بها. يُفيد هذا القسم القادمين الجدد إلى عالم البرمجة، ويفيد أيضًا المبرمجين بلغات أخرى الّذين لم يسبق لهم الاطّلاع على الجوانب المميّزة لـJavaScript.

فيما يلي برنامج JavaScript بسيط يُضيف رسالةً إلى صفحة ويب:

```javascript
// create a function that will greet a person,
// and assign the function to the `greet` variable
var greet = function( person, message ) {
  var greeting = 'Hello, ' + person + '!';
  log( greeting + ' ' + message );
};

// use the function to greet Jory, passing in her
// name and the message we want to use
greet( 'Jory', 'Welcome to JavaScript' );

// use the function to greet Rebecca, passing in her
// name and a different message
greet( 'Rebecca', 'Thanks for joining us' );
```

_مُلاحظة: في المثال السابق، استخدمنا الدّالّة `log`. وهي دالّة مُساعِدة متوفّرة في الأمثلة في هذه السّلسلة فقط، وليست متوفّرة تلقائيًّا في JavaScript، يمكن استخدام `log` في محرّر النّصوص البرمجيّة في هذه السّلسلة، ولكن ستحتاج إلى استخدام `console.log` محلّها في النّصوص البرمجيّة خارج السّلسلة، وعندها ستُطبع نتائج النّصّ إلى طرفيّة المتصفّح الّذي تستعمله._

<a class="jsbin-embed" href="http://jsbin.com/giqudi/3/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

المثال السابق يعرض نتيجة تنفيذ النّص البرمجيّ ضمن قسم Console، يمكنك إعادة ضبط المثال باستخدام الزر Clear ثمّ تعديل النصّ إن رغبت بالتجربة وإعادة تنفيذه بنقر Run. لا بأس إن بدت بعض الأشياء غير مفهومة الآن؛ ففي الفقرات التّالية سنطّلع على مفاهيم المتغيّرات والدوالّ والمكوّنات الأساسيّة الأخرى لـJavaScript.

##ملاحظة عن التعليقات
تفيد التّعليقات في شرح ما يفعله كل جزء من النصّ البرمجيّ، ولا تؤثّر التعليقات في عمل البرنامج على الإطلاق. بعض المُبرمجين يحبّون الإكثار من التعليقات في برامجهم، بينما يفضّل آخرون كتابتها فقط عندما تكون بعض الأجزاء من النّصّ غامضة ولا تتضّح بسهولة.

تسمح JavaScript بنوعين من التعليقات: مفردة السّطر، ومتعدّدة السّطور، ويبدأ الشّكل الأوّل بالحرفين `//`؛ بينما يبدأ الثّاني بالحرفين ‎`\*`‎ وينتهي بـ‎`*/`‎.

```javascript
// هذا تعليق مُفرد السّطر
var foo;

/*
  هذا تعليقٌ متعدّد السّطور
  يمكن أن يمتدّ على أكثر من سطر، كما ترى.
 */
```

يمكن أيضًا استخدام التّعليقات متعدّدة السّطور مُضمّنة ضمن سطرٍ من النّصّ البرمجيّ:

```javascript
function cornify( unicorns /* عدد صحيح */, rainbows /* عدد صحيح */ ) {

}
```

##المكوّنات الأساسيّة لـJavaScript
###المُتغيِّرات (Variables)
المُتغيّرات هي الطّريقة الّتي نخزّن بها القيم الّتي نريد استخدامها في وقت لاحقٍ. يمكن أن تكون المتغيّرات على عدّة أنواع من نصوصٍ أو أعداد أو بياناتٍ أخرى كالمصفوفات والكائنات، أو حتى نصوصًا برمجيّة (بصورة دالّة مُخزّنة في متغيّر). يُصرّح عن المتغيّر بجملة `var`:

```javascript
var myName = 'Rebecca';
```

يمكن اختيار أي اسم للمتغيّر بشرط ألّا يبدأ الاسم برقمٍ وألّا يحوي إشارة النّاقص "-".

بإمكانك التّصريح عن متغيّر واحدٍ في كلّ جملة:
```javascript
var a = 1;
var b = 'two';
```

أو التّصريح عن عدّة متغيّرات في جملة واحدة بفصلها بفواصل لاتينيّة:

```javascript
var a = 1,
    b = 'two';
```

بعد إسناد قيمة للمتغيّر، يمكن استخدام هذا المتغيّر للوصول إلى القيمة المُخزّنة فيه:

```javascript
log( myName ); // يطبع 'Rebecaa'
```
المتغيّرات مكوّن ضروريّ للالتزام بمبدأ "لا تكرّر نفسك" (Don't Repeat Yourself)، فإذا أردت استخدام قيمة واحدة أكثر من مرّة، فالغالب أنّك ترغب في تخزينها في مُتغيّر.

سنتحدّث عن المتغيّرات بتفصيل أكبر في الفقرة القادمة.

###الدّوالّ (Functions)
الدّوال مكوّن أساسيّ في برامج JavaScript لأنّها توفّر وسيلة لتهيئة وظائف صغيرة في البرنامج بصورة جزء مستقلّ ومنظّم. افترض مثلًا دالّة تجمع عددين:

```javascript
function(a, b) {
    return a + b;
}
```

تأخذ هذه الدّالة **مُعاملين** اثنين هما `a` و`b`، تجمعهما ثمّ تعيد المجموع كنتيجة الدّالّة.

المثال السّابق هو برنامج JavaScript سليم الصّياغة، لكنّه لا يفعل شيئًا على الإطلاق، لأنّه ما من طريقة تسمح لنا بأن نطلب من هذه الدّالة أن تجمع أي عددين بعدُ. علينا إذًا إيجاد طريقة *لاستدعاء* الدّالّة، ويمكننا فعل ذلك بإسنادها أولًّا إلى متغيّر:

```javascript
var addTwoNumbers = function(a, b) {
  return a + b;
}
```

ما فعلناها في المثال الأخير هو أنّنا أخذنا **تعبيرًا عن دالّة (function expression)** وأسندناه إلى مُتغيّر. يمكننا الآن استدعاء هذه الدّالة باستخدام اسم المتغيّر:

```javascript
log( addTwoNumbers(1, 1) ); // تطبع 2
```

يمكننا بدلاً من ذلك استخدام **تصريح عن دالّة (function declaration)** لإعطاء دالّتنا اسمًا:

```javascript
function addTwoNumbers(a, b) {
  return a + b;
}
```

وكلا الطّريقتين تسمحان لنا باستدعاء دالّتنا بالأسلوب نفسه، ولكن يجب الحذر عند اعتماد الأسلوب الأخير لأسباب تشرحها [هذه التّدوينة](http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/).

الخلاصة: تسمية الدّوالّ بالتّصريح عن الدّالّة قد تؤدّي إلى نتائج غير مُتوقّعة إن لم تفهم بدقّة إحدى ميّزات JavaScript المعروفة باسم "الرّفع إلى أعلى النّطاق" (hoisting). تفصيل هذه الميزة موضوعٌ خارج عن نطاق هذه السّلسلة، ولكنّنا سنعتمد إسناد الدّوال إلى المُتغيّرات في الوقت الحاليّ.

###الدّوال ونطاق المُتغيّرات (Variable scope)
تكون المُتغيّرات الّتي تُعرَّف ضمن دالّة بجملة `var` مُتاحة فقط من داخل هذه الدّالّة، وهذا أمر مرغوبٌ عادةً، ولذا يجب التّصريح عن كلّ المُتغيّرات في البرنامج باستخدام جمل `var` ما لم يُقصد جعلها عامّة (global)، أي متاحةً عبر كامل البرنامج وفي أيّ موضع منه. ليس هذا ما نُريده عادةً إلّا إذا أردنا تغيير قيمة المُتغيّر من نصّ برمجيّ آخر.

ولكن ما معنى أن تكون المُتغيّرات مُتاحةً فقط داخل الدّالّة؟ جرّب هذا البرنامج:

**تحذير: نصّ برمجيّ خاطئ**

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/3/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

لو أنّنا حاولنا في المثال السّابق استخدام قيمة `foo` خارج الدّالة (بدل الاكتفاء بفحص نوعها)، لأبلغنا المُتصفّح بوجود خطأ، ولن يتابع البرنامج العمل فيما يلي الموضع الّذي استخدمنا  `foo` عنده.

المثال التّالي يبيّن كيف يمكن لمُتغيّرين مختلفين أن يوجدا باسمٍ واحد طالما أنّ كلًّا منهما موجود في نطاق منفصل عن الآخر. في هذا المثال نُصرّح عن المُتغيّر `foo` ونسند إليه القيمة `'qux'`، ثم نُصرّح عن مُتغيّر آخر داخل دالّة، ونُسمّيه `foo` أيضًا، ونُسند إليه القيمة `'bar'`. لاحظ أنّ المُتغيّر `foo` خارج الدّالة لا يتغيّر حتّى بعد أن نُنشئ المُتغيّر `foo` داخل الدّالة.

```javascript
var foo = 'qux';
var myFunction = function() {
  var foo = 'bar';
};

log( foo ); // تطبع 'qux'
myFunction();
log( foo ); // تطبع 'qux' أيضًا
```

على الرّغم من تشارك المُتغيّرين اسمًا واحدًا، إلّا أنّ JavaScript تعتبرهما شيئين مختلفين بالكامل، وهذا واحد من عدّة أسباب تدفعك لإعطاء مُتغيّراتك أسماء مُعبّرة.

نطاق المُتغيّرات مفهوم جوهريّ في JavaScript، ولعلّه يسبّب بعض الارتباك للمبتدئين. تذكّر:

* في الأغلبية السّاحقة من الحالات، صرّح عن المُتغيّرات بجملة `var`
* لا يمكن الوصول إلى المُتغيّرات المفروضة داخل دالّة بجملة `var` من خارج هذه الدّالّة
* المُتغيّرات الّتي تُفرض بلا جملة `var` تكون عامّةً دائمًا

انتبه إلى أنّ المُتغيّرات الّتي يُصرَّح عنها بلا الكلمة `var` تكون ضمنيًّا عامّةً. في المثال التّالي لدينا المُتغيّر `a` المتاح خارج الدّالة لأنّ عُرِّف بدون الكلمة `var` (وهذا أمرٌ غير مرغوب في معظم الحالات).

**تحذير: نصّ برمجيّ غير آمن**

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/4/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

###الكائنات (Objects)
الحقيقة أنّ معظم ما نتعامل معه في JavaScript ليس سوى كائنات، وليس في اللّغة إلّا 5 أنواع من القيم الّتي *لا* تُعتبر كائنات:

* السلاسل النّصيّة (strings)
* القيم المنطقية (true/false)
* الأعداد
* `undefined` (غير مُعرّف)
* `null` (معدوم)

تُسمّى القيم السّابقة **بالأنواع الأوّليّة (primitives)**، ويمكن حتّى لبعض هذه القيم أن تُعامل كما لو أنّها كائنات (سنشرح هذا بعد قليل). ولكن ما الكائن؟ لنُلقِ نظرةً على كائنٍ بسيط:
```javascript
var person = {
  firstName: 'Boaz',
  lastName: 'Sender'
};
```
للكائن الّذي أنشأناه أعلاه **خاصّتان** اثنتان **(properties)**:‏ `firstName` و`lastName`. أنشأنا الكائن بصياغة "الكائن الحرفيّ (object literal)" أي بإحاطة مجموعة من أزواج مفتاح/قيمة بقوسين معكوفين `{}`. لاحظ أنّ نقطتين (`:`) تفصلان بين المفتاح والقيمة وأنّ فاصلة لاتينيّة (`,`) تفصل بين كلّ زوجين. لاحظ أنّه ما من فاصلة بعد الزّوج الأخير، وإن أضفتها سهوًا فستقع أخطاء عند تنفيذ البرنامج في المتصفّحات القديمة.

####الوصول إلى الخصائص
حفظنا الكائن في مُتغيّر أسميناه `person`، ممّا يُسهّل الوصول إلى خصائصه، إمّا باستخدام _أسلوب النّقاط (dot notation)_ أو _أسلوب الأقواس المُربّعة (bracket notation)_.

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/5/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

ستلاحظ أنّنا استخدمنا سلسلة نصّيّة (string) للوصول إلى اسم الخاصّة الّتي نريدها عند اعتماد أسلوب الأقواس المُربّعة. أمّا عند اعتماد الأسلوب الآخر، أسلوب النّقاط، فقد استخدمنا اسم الخاصّة نفسه دون علامتي الاقتباس. يفيد أسلوب الأقواس المُربّعة عندما نريد الوصول إلى خاصّة يُحفَظ اسمها ضمن مُتغيّر:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/6/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

بعد أن أنشأنا الكائن، يمكننا تعديل خصائصه:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/7/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

هذا الجانب في JavaScript هو نعمة ونقمة في الوقت ذاته، فهو يعني أنّ الكائنات مرنة بصورة فائقة، ولكنّه أيضًا يعني أنّه ما من "خصوصيّة" للكائنات، فيمكن لأيّ نصّ برمجيّ أن يُسند قيمةً جديدة إلى أيّ خاصّة في أيّ كائن يمكنه الوصول إليه؛ وهذا سبب آخر يدفعك للاحتفاظ بالمُتغيّرات معزولةً عن النّطاق العامّ إلّا إذا كنت تريد فعلًا للبرامج الأخرى أن تُغيّر تلك الخصائص.

####وظائف الكائنات (Object methods)
**الوظائف (methods)** هي خصائص في الكائن قيمها دوالّ (functions)، لنُضِف وظيفة ‎`.greet()`‎ إلى كائن `person`:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/8/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

استقبلت الوظيفة  ‎`.greet()`‎ في المثال السّابق النّصّ `name` كُمعامِل لها. عند استدعاء هذه الدّالة، أرسلنا قيمة الخاصّة `firstName` لكائن `person` ببساطة. لو أردنا وظيفة فائقة المُرونة تُلقي التّحيّة على أيّ شخص، فلرّبما يكون ما كتبناه صحيحًا. ولكن الغالب أنّنا نريد لوظيفتنا أن تُلقي التّحيّة على الشّخص المُحدّد في الكائن `person` فقط.

####معنى `this`
داخل كلّ وظيفة (وداخل كلّ دالّة) تتوفّر كلّمة مفتاحيّة خاصّة: `this`، وهي تُشير إلى الكائن الّذي يُمثِّل السّياق الّذي اُستدعيت فيه الدّالة.

عندما نستدعي `person.greet()‎` يكون السّياق هو الكائن `person` ذاته. معنى هذا أنّ بإمكاننا استخدام `this` للوصول إلى إحدى خصائص الكائن `person` مباشرة من داخل الوظيفة ‎`.greet()`‎.

_ملاحظة: معنى `this` قد يُسبّب ارتباكًا شديدًا لمطوّري JavaScript المُبتدئين، يمكنك الاطمئنان إن لم تفهم بدقّة معناها، لأنّ jQuery تُحسن استغلالها بحيث لا تضطّر للدّخول في تفاصيلها؛ ومع ذلك فلا يكتمل الحديث عن الكائنات ووظائفها دون الإشارة إلى `this` وإن قليلًا. سأترك لك حرّيّة الانتقال إلى فقرة "الكائنات في jQuery" من هذه المقالة إن شئت، ثمّ عُد إلى هنا عندما تشعر أنّك جاهز لفهمها تمامًا._

لنحاول فهم كيف يمكن استخدام `this` في وظيفتنا:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/9/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

ليست مُعقّدةً كثيرًا حتى الآن... صحيح؟ منشأ التّعقيد هو أنّ _معنى `this` يمكن أن يتغيّر_، فالأمر كما قلنا يعتمد على السّياق الّذي استدعيت فيه الدّالة! لاحظ النّصّ التّالي:

**تحذير: نصّ برمجيّ خاطئ**

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/10/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

عندما نحقظ الوظيفة  ‎`.greet()`‎ في مُتغيّر `sayIt` ثمّ نستدعي `sayIt()‎`، فإنّ السّياق يتغيّر ليُصبح الكائن العامّ `window`، _لا الكائن `person`_. وبما أنّ ليس للكائن `window` خاصّة اسمها `firstName`، فإنّ النتيجة تكون `undefined` عندما نحاول الوصول إليها.

ما الذي على المُبرمج فعله إذًا؟ أوّلًا: عليه أن يحذر من النّتائج غير المُتوقّعة لمعنى `this` عند تخزين وظائف الكائنات في متغيّرات. وثانيًا: عليه أن يعلم أنّ بإمكانه إجبار `this` أن تُشير إلى ما يشاء من الكائنات وذلك باستخدام إحدى الوظيفتين  ‎`.call()`‎ و‎`.apply()`‎ مع الدّالّة ذاتها.

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/11/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

كلا الوظيفتين المُتشابهتين ‎`.call()`‎ و‎`.apply()`‎ تُتيحان إمرار المُعاملات إلى الدّالّة الّتي تُستدعى بهما. تخيّل أنّ دالة التّحيّة تقبل بعض المعاملات، يمكن حينئذٍ إمرار هذه المُعاملات باستخدام ‎`.call()`‎ كما يلي:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/12/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

يمكن تنفيذ الأمر ذاته باستخدام ‎`.apply()`‎، ولكن سنحتاج معها إلى إمرار المُعاملات ضمن مصفوفة واحدة بدلًا من إمرارها مُنفصلة:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/13/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

_مُلاحظة: لتفاصيل أكثر عن ‎`.call()`‎ و‎`.apply()`‎، راجع وثيقتي شبكة مُطوِّري موزيلّا [‎`.call()`‎](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call) و[‎`.apply()`‎](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply)،_

####الكائنات في jQuery
لم نتطرّق بعدُ إلى تفاصيل الكائنات في JavaScriptن لكنّك الآن تعرف الأساسيّات الّتي تُتيح لك التّعامل مع الكائنات خلال تعلّمك jQuery، ففيها ستستعمل الكائنات لضبط الخيارات، كتغيير عدّة خصائص  CSS لعنصر في الصّفحة مرّة واحدة:

```javascript
$('#main').css({
  color: 'red',
  border: '1px solid blue'
});
```

بخصوص `this`، فإنّ `jQuery` تُسيطر على معناها، وفي حالة مُتولّيات الأحداث (event handlers)، تُشير `this` إلى العنصر في الصّفحى الّذي ربطتّه بالمُتولّي، وفي حالة سرد مجموعة من الكائنات في تحديدٍ، تُشير `this` إلى العنصر الحاليّ في السّرد. ليس عليك الحرص على فهم `this` بدقّة في المراحل الأولى لتعلّمك، بل اكتفِ بإبقاء فكرتها في ذهنك أثناء تعلّمك.

####تفاصيل أكثر
يتوسّع [دليل JavaScript في شبكة مُطوِّري موزيلّا](https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Working_with_Objects) في شرح مواضيع مثل النّماذج البدئيّة للكائنات (object prototypes) والدّوال المُشيِّدة (constructor functions) وحذف خصائص الكائنات.

###المصفوفات (Arrays)
المصفوفات نوعٌ من الكائنات تُستخدم لحفظ قائمة من القيم، وهي وسيلةٌ سهلة لتخزين مجموعة من العناصر المترابطة من نفس النّوع (كالسّلاسل النّصيّة)، مع أنّ الواقع أنّه لا شيء يمنع مصفوفةً من أن تحوي عدّة أنواع من العناصر، بما في ذلك مصفوفاتٍ أخرى.

الطّريقة المُفضّلة لإنشاء مصفوفة استخدامُ أسلوب المصفوفات الحرفيّة:

```javascript
var myArray = [ 'a', 'b', 'c' ];
```

_ملاحظة: ستقرأ من وقتٍ لآخر برامج تُنشئ المصفوفات بالأسلوب التالي: `new Array('a', 'b', 'c')` وهو أسلوب غير مقبولٍ وسط مُطوّري JavaScript لأنّه لا يختلف عن الأسلوب الأوّل سوى في أنّ له عيوبًا ليست في الأوّل! فمثلاً: كتابة `new Array(3)` تعني إنشاء مصفوفة فيها ثلاث عناصر كلّها غير مُعرّفة، بدلاً من إنشاء مصفوفة فيها العدد 3 (أي بدلًا من `[ 3 ]`)._

يمكن الوصول إلى خصائص المصفوفات (الّتي تُسمّى أحيانًا **بعناصر المصفوفة** (elements)) باستخدام صياغة الأقواس المربّعة ذاتها المستخدمة مع الكائنات، فكلّ عنصر يُعطى اسما تلقائيًّا بحسب موقعه في المصفوفة. ولكن عليك الحذر: فالأعداد تبدأ من الصّفر. لنُلق نظرة على مصفوفة فيها 3 عناصر:

**تحذير: أسلوب غير مُفضّل**

```javascript
var myArray = [ 'a', 'b', 'c' ];
var firstItem = myArray[ "0" ]; // الوصول إلى العنصر الأوّل
``

عند الوصول إلى عناصر المصفوفة، فإنّه من الأسهل استخدام الأعداد لتحديد موضع العنصر المطلوب في المصفوفة، والّذي يُسمّى **الدّليل (index)**:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/14/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

يمكننا معرفة عدد العناصر في مجموعة بالوصول إلى الخاصّة `length` في المصفوفة:

<a class="jsbin-embed" href="http://jsbin.com/wavipizone/15/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

####حلقات `for`: سرد المصفوفات

