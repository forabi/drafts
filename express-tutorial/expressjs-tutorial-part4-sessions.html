<h1 id="-node-js-express">إدارة الجلسات في Node.js وExpress</h1>
<p>لا قيمة لمدوّنتنا إن لم يكن باستطاعتنا كتابة التّدوينات الجديدة ونشرها، لذا علينا إنشاء صفحة تُتيح لنا (لنا فقط) كتابة تدوينة جديدة وحفظها في قاعدة البيانات. لكن أوّل ما يتبادر إلى الذّهن تساؤل عن الكيفيّة الّتي نستطيع أن نمنع فيها الزّائر من إضافة التّدوينات، إذ كيف يستطيع المتصفّح والخادوم التّفريق بين صاحب المدوّنة وزائرها؟</p>
<p>ملايين المواقع على الويب تقدّم محتوىً مخصّصًا لكلّ مستخدم، إذا عدنا لمثال فيس بوك وطرحنا السؤال ذاته: كيف يعرض فيس بوك نشرة أخبار خاصّة بكلّ مستخدم؟ بالطّبع لكلّ مستخدم حساب في الموقع محميّ بكلمة مرور، لكن ما الذي يحدث بين المتصفّح والخادوم ويجعل الخادوم يُرسل الصّفحة الخاصّة بالمستخدم إليه دون غيره؟</p>
<p>إن كنت سمعت من قبل بالكعكات (cookies) ولم تعرف ما علاقتها بالويب، فقد حان الوقت لنعرف ما هي وكيف تستخدم.</p>
<h3 id="-cookies-">الكعكات (Cookies)</h3>
<p>الكعكات هي أجزاء صغيرة من البيانات تخزّن في المتصفّح وتنتقل بينه وبين الخادوم مع كلّ طلب إلى هذا الخادوم (كترويسة Heading في طلب HTTP)، يمكن للخادوم أن يأمر المتصفّح بحفظ بيانات جديدة ضمن الكعكات، ويمكن للمتصفّح منع تخزين هذه البيانات بأمر المستخدم أو حذفها متى شاء. تُستخدم الكعكات بشكل شائع لتخزين &quot;الجلسة&quot; (session)، وهي الطّريقة الّتي يتذكّر بها الخادوم هذا المتصفّح بين الطّلب والآخر بحيث يستطيع تمييزه من بين الطّلبات الّتي تصله من حواسيب مختلفة حول العالم.</p>
<p>من المهمّ أن نعرف أنّ طلبات HTTP هي طلبات مستقلّة بذاتها وعديمة الحالة (stateless)، بمعنى أن كلّ طلب يصدر من المتصفّح للخادوم نفسه لا يعرف أيّ شيء عن الطّلبات السّابقة أو اللاحقة، وكذلك الخادوم؛ إلا إذا تمّ إرفاق معرّف مُميّز (session ID) يتّفق عليه الطّرفان وينتقل مع كلّ طلب بين الجهتين. بدون الجلسات كنت ستحتاج إلى إدخال اسم مستخدمك وكلمة المرور في كلّ مرة تنتقل فيها إلى صفحة جديدة على فيس بوك!</p>
<p>من المهمّ إذًا أن يكون معرّف الجلسة (session ID) مُميّزًا للمتصفّح ولا يتطابق مع معرّف جلسة أي متصفّح آخر، وهذا يتمّ بتوليد معرّف الجلسة بشكل عشوائي على الخادوم أولًا ثمّ إرساله للمتصفّح لحفظه ضمن الكعكات، وسيقوم المتصفّح بنقل الكعكات مع كلّ طلب، ممّا يسمح للخادوم بمعرفة تتابع الطّلبات من نفس المتصفّح.</p>
<p>من الاستخدامات الأخرى للكعكات تتبّع المستخدمين بين المواقع عن طريق استضافة محتوى من طرف ثالث ضمن صفحة الموقع (third-party cookies) وهي حيلة تستخدم لمعرفة ذوق المستخدم وتوجّهه من خلال أنواع المواقع الّتي يزورها وبالتّالي استهدافه بالإعلانات أو مراقبة نشاطه. لا غرابة أن تعطينا المتصفّحات وسيلة لمنع كعكات الطّرف الثّالث، أو لمنع الكعكات بالكامل!</p>
<p>لنلخّص الأمر: تسمح الجلسات بربط طلبات HTTP المتتالية بحيث يتعرّف الخادوم على كونها صادرة من جهة واحدة، مما يسمح له بتخصيص الإجابة على هذه السلسلة من الطّلبات دون غيرها، سنستفيد من هذا في حفظ تسجيل الدّخول المستخدم بحيث لا نطلب منه كلمة المرور عندما ينتقل من صفحة لأخرى. لنعد الآن إلى شيفرة تسجيل الدّخول ولنفكّر، ما الذي نحتاجه لحفظ الجلسة؟</p>
<p>عندما يُسجّل المستخدم دخوله للمرّة الأولى، نحتاج إلى حفظ مُعرّف الجلسة على الخادوم ليكون بإمكاننا مقارنته مع الطّلبات التّالية، وهذا يعني أنّنا بحاجة لوسيلة لحفظ معرّف الجلسة لكل مستخدم. في Express يتوفّر البرنامج الوسيط <code>express-session</code> الذي يتولّى هذه المهمّة كاملةً. قم بتثبيت هذه الوحدة، ثم لنقم باستيرادها:</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
// ...

var session = require(&#39;express-session&#39;);
</code></pre>
<p>نريد استخدام <code>express-session</code> على مستوى التّطبيق بالكامل، ما يعني أنّنا نريد لها أن تتعقّب كلّ الطّلبات على جميع الرّوابط المسجّلة مما يسمح بمتابعة الجلسة، تسمّى هذه الوحدات البرامج الوسيطة على مستوى التّطبيق (Application-level middleware) بعكس الأسلوب الّذي استخدمناه في <code>body-parser</code> لتفسير متن الطّلب في نماذج إنشاء المستخدم وتسجيل الدّخول (برامج وسيطة على مستوى المُوجّه Router-level middleware). يمكن للوحدة أن تُستعمل بالأسلوبين.</p>
<p>تستخدم الوحدات على مستوى التّطبيق باستدعاء الوظيفة <code>use()‎</code> لتطبيقنا:</p>
<pre><code class="lang-javascript">app.use(session({
    secret: &quot;my top secret&quot;,
    resave: false,
    saveUninitialized: true
}));
</code></pre>
<p>تستقبل وحدة <code>session</code> كائن الإعدادات الذي يتضمّن:</p>
<ul>
<li><code>secret</code>: كلمة سرّيّة تسمح بتجزئة معرّف الجلسة لحمايته، ضع ما تشاء هنا.</li>
<li><code>resave</code>: هل يجب كتابة الجلسة مع كلّ طلب حتّى وإن لم تتغيّر؟</li>
<li><code>saveUninitialized</code>: هل يجب حفظ الجلسات الجديدة تلقائيًّا إلى الخادوم؟</li>
</ul>
<p>لا تقلق إن كانت هذه الإعدادات غامضة، ستتعرّف على فائدتها مع مرور الوقت.</p>
<p>تذكّر أنّ ترتيب استدعاءات البرامج الوسيطة مهمّ، يجب أن نضيف الشّيفرة السّابقة قبل تسجيل الروابط لنتمكّن من متابعة الجلسة عبر كلّ الرّوابط المسجّلة.</p>
<p>حسنًا من المفترض الآن أن يقوم المتصفّح بحفظ معرّف الجلسة ثم نقله مع كلّ طلب، لنتحقّق من هذا؛ شغّل البرنامج ثم زر الصفحة الرئيسية للمدوّنة، افتح أدوات المطوّرين (<code>Ctrl + Shift + K</code> في فيرفكس)، ثم انتقل إلى تبويب الشّبكة واضغط زر إعادة تحميل الصّفحة، سيبدأ المتصفّح بمراقبة الطّلبات، سيظهر طلب للصفحة الرئيسيّة مع بداية تحميلها، انقر عليه وابحث عن ترويسة <code>Cookie</code> في الجانب، لاحظ أنّها تحوي قيمة <code>connect.sid</code>، وهذا هو المعرّف المميّز الذي سينتقل بين الطّلبات، للتأكد من ذلك انتقل إلى صفحة أخرى مثل <code>‎/posts/hello-world</code> وكرّر العمليّة، ستجد أن معرّف الجلسة ثابت لا يتغيّر.</p>
<p><img src="devtools-cookie-header.jpg" alt="ترويسة Cookie في الطّلب"></p>
<p>عظيم! أصبح بإمكاننا الآن تمييز الطّلبات ومتابعتها، لكن ما الفائدة التي جنيناها إلى الآن! في الحقيقة لا شيء، نحتاج إلى الاستفادة من كون معرّف الجلسة مميّزًا بحيث نعلم أن المستخدم الذي تحمل طلباته هذا المعرّف قد سجّل دخوله فلا نطلب منه كلمة المرور في كلّ طلب، وسنستفيد من ذلك أيضًا في تخصيص محتوى الصّفحة وإتاحة وصول الكُتَّاب إلى صفحة إنشاء التّدوينات فيما بعد.</p>
<p>نحتاج إلى حفظ معرّف الجلسة في جدول بقاعدة البيانات لنتمكّن من طلبه لاحقًا ومقارنته مع الطّلبات القادمة، لنُنشئ جدولاً يحفظ معرّفات الجلسات لكلّ مستخدم:</p>
<pre><code class="lang-sql">CREATE TABLE `sessions` (session_id VARCHAR(100) NOT NULL PRIMARY KEY, username VARCHAR(50) NOT NULL, FOREIGN KEY (username) REFERENCES `users` (username), INDEX (username));
</code></pre>
<p>من المهمّ أن نفهم أنّ معرّف الجلسة يحلّ محلّ كلمة المرور واسم المستخدم معًا، لهذا من الضّروري أن يكون مميّزًا (<code>PRIMARY KEY</code>) بحيث لا يتطابق معرّفان لمستخدمين مختلفين، من المهمّ، للسبب ذاته، حماية الجلسة وتوليدها بطريقة عشوائية، وهذا هو سبب استخدامنا للكلمة السّريّة <code>secret</code> في إعدادات <code>express-session</code>، من إجراءات الأمان الشّائعة إضافة مهلة تنتهي بعدها صلاحيّة الجلسة، وهذا هو السّبب الذي تطالبك لأجله بعض المواقع بإعادة تسجيل دخولك بعد فترة من الزّمن؛ لكنّنا لن نُشغل بالنا بهذه التّفاصيل الآن.</p>
<p>حسنًا لدينا الآن معرّف الجلسة وجدول لحفظه، كل ما نحتاجه عند تسجيل الدّخول بشكل صحيح حفظ معرّف الجلسة إلى الجدول، لنعد إذًا إلى شفرة تسجيل الدّخول الّتي تركناها في الفقرة السّابقة:</p>
<pre><code class="lang-javascript">/*
...
*/

var cookieParser = require(&quot;cookie-parser&quot;);
app.use(cookieParser());

/*
...
*/

app.post(&quot;/sessions&quot;, parseBody, function(request, response, next) {
    var username = request.body.username;
    var password = request.body.password;

    if (!username || !password) {
        response.status(400);
        response.send(&quot;يجب توفير اسم المستخدم وكلمة المرور&quot;);
        return;
    }

    connection.query(&quot;SELECT username, password FROM `users` WHERE username=?&quot;, [ username ], function(err, rows) {
        var user = rows[0];
        if (!user) {
            response.status(400);
            response.send(&quot;لا يوجد مستخدم يطابق اسمه اسم المستخدم المطلوب&quot;);
            return;
        }

        bcrypt.compare(password, user.password, function(err, result) {
            if (err) {
                response.status(500);
                response.send(&quot;وقع خطأ من جهة الخادم، حاول تسجيل الدخول لاحقًا&quot;);
                return;
            }

            if (result == true) {

                connection.query(&quot;INSERT INTO `sessions` (session_id, username) VALUES (?, ?)&quot;, [ request.cookies[&quot;connect.sid&quot;], username ], function(err) {
                    if (err) return next(err); // تعامل مع الخطأ
                    response.status(200);
                    response.send(&quot;تم تسجيل الدّخول&quot;);
                })

            } else {
                response.status(401);
                response.send(&quot;كلمة المرور التي أرسلتها خاطئة&quot;);
            }

        })
    });

})
</code></pre>
<p>توفّر لنا <code>express-session</code> معرّف الجلسة ضمن الكعكة تحت الاسم <code>connect.sid</code> والذي يمكن تغييره بضبط القيمة <code>name</code> في إعدادات الوحدة. استخدمنا الوحدة <code>cookie-parser</code> التي تقوم بما يوحي به اسمها وتوفّر لنا الكعكات ضمن كائن الطّلب للحصول على معرّف الجلسة.</p>
<p>نكاد ننتهي من إنشاء نظام المستخدمين، بقي علينا فقط إرفاق معلومات المستخدم مع كلّ دالّة توجيه لنتمكّن من عرض اسم المستخدم في الصّفحة وإتاحة تسجيل الخروج، بل يمكننا أيضًا توجيهه إلى صفحات خاصّة به أو منعه من الوصول إلى صفحات أخرى، سنقوم بإضافة دالّة توجيه تسبق جميع روابطنا وتقوم بإرفاق بيانات المستخدم (بعد جلبها من قاعدة البيانات) وإضافتها إلى كائن الطّلب:</p>
<pre><code class="lang-javascript">app.use(function(request, response, next) {
    var session_id = request.cookies[&quot;connect.sid&quot;];
    if (session_id) {
        connection.query(&quot;SELECT users.id, users.username, full_name, is_author FROM `users` JOIN `sessions` ON users.username=sessions.username WHERE session_id=?&quot;, [ session_id ], function(err, rows) {
            if (!err &amp;&amp; rows[0]) {
                request.user = rows[0];
            }

            next();
        })
    } else {
        next();
    }
})
</code></pre>
<p>في الحقيقة، ما كتبناه للتوّ ليس سوى برنامج وسيط، لا يختلف في شيء عن البرامج الوسيطة التي استعملناها مثل <code>express-session</code> عدا أنّ الأخيرة يوفّرها مطوّرون آخرون كحزمة على npm يمكن استيرادها.</p>
<p>في دوال التّوجيه التّالية، سيتوفّر لدينا كائن <code>request.user</code> يتضمّن معلومات المستخدم الحالي، لنجرّب ذلك بإنشاء صفحة الملفّ الشّخصي للمستخدم (<code>views/profile.jade</code>):</p>
<pre><code class="lang-jade">doctype html
html(lang=&quot;ar&quot;, dir=&quot;rtl&quot;)
    head
        title الملف الشخصي
    body
        style
            :css
                body {
                    font-family: Arial, sans-serif;
                }

        if (user)
            h1 #{ user.full_name } (#{ user.username })
            hr
        else
            p لم تقم بتسجيل دخولك
</code></pre>
<pre><code class="lang-javascript">app.get(&quot;/profile&quot;, function(request, response) {
    response.render(&quot;profile&quot;, { user: request.user })
})
</code></pre>
<p>سنقوم بتوفير الكائن <code>request.user</code> للقالب، والذي سيكون غير معرّف إن لم يُوجد في قاعدة البيانات أو إن لم يسجل المستخدم دخوله، سيتولى القالب هذه الحالة ويعرض الرسالة المناسبة. لاحظ دعم Jade للجمل الشّرطيّة.</p>
<p>حسنًا، لنجرّب الآن ما كتبناه، شغّل البرنامج ثم زر الصفحة <a href="http://localhost:3000/login،">http://localhost:3000/login،</a> سجّل الدّخول باسم المستخدم admin وكلمة المرور 123456، من المفترض أن تنتقل إلى صفحة تخبرك بنجاح العملية، الآن انتقل إلى <a href="http://localhost:3000/profile">http://localhost:3000/profile</a> لتشاهد الملف الشّخصيّ (حسنًا لا يبدو عظيمًا جدًّا، لكنّنا سنحسّنه لاحقًا):</p>
<p><img src="profile-signed-in.jpg" alt="الملف الشخصي للمستخدم admin‏"></p>
<p>تهانينا! لقد أنشأنا نظامًا للمستخدمين وأصبح بإمكاننا عرض محتوى مخصّص لكلّ مستخدم! في الجزء القادم سنتيح لأنفسنا كتابة التّدوينات، وللمستخدمين إضافة التعليقات، وستكون أعظم مدوّنة في التّاريخ!</p>

